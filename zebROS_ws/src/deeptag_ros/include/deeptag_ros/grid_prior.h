#ifndef GRID_PRIOR_INC__
#define GRID_PRIOR_INC__
#include <cuda_runtime.h>
#include "grid_prior_value.h"
#include "span.hpp"

// Class to handle all of the GridPrior ops.
// Stores the grid priors (a map from model output indexes to image coords) along
// with the [resized] input image H+W + stride
// Also stores a buffer for outputs generated by the convertLocationToKpts function.
//  That's here since all that's needed to allocate it is the image size + stride, so keeping
//  it here lets users create a GridPrior of the appropriate size and then just blindly call
//  the convertLocation function with the correct model output / function input and everything is
//  handled correctly.

// They'll still need something to deal with the output, unless code there knows what the correct
// sizes are as well?  Still figuring that out
template <size_t NUM_TILES, bool USE_SCALED_IMAGE, bool CLAMP>
class GridPrior
{
public:
    GridPrior();

    GridPrior(const GridPrior &other) = delete;
    GridPrior(GridPrior &&other) noexcept = delete;

    GridPrior &operator=(const GridPrior &other) = delete;
    GridPrior &operator=(GridPrior &&other) noexcept = delete;

    virtual ~GridPrior();
    bool generate(const ushort2 &modelInputSize,
                  const uint32_t stride,
                  const ushort2 &imageSize,
                  const std::array<ushort2, NUM_TILES> &tileOffsets,
                  cudaStream_t cudaStream);
    const tcb::span<const GridPriorValue> getOutput(void) const;

    // Verify enough space is allocated for the input image h,w,stride, 
    // if so, return false
    // if not, reallocate currBuffer, update currSize, return true
private:
    static constexpr size_t NUM_SCALED_IMAGES{USE_SCALED_IMAGE ? 1 : 0};
    ushort2 *m_dOffsets{nullptr};
    ushort2 *m_hOffsets{nullptr};
    GridPriorValue *m_dGridPriors{nullptr};
    ushort2 m_modelInputSize{0, 0};
    ushort2 m_imageSize{0, 0};
    uint32_t m_stride{0};
};
#endif